{
  "version": 3,
  "sources": ["src/model-info.ts"],
  "sourcesContent": ["import {\n  BooleanModel,\n  NumberModel,\n  StringModel,\n  _meta,\n  createDetachedModel,\n  type AbstractModel,\n  type DetachedModelConstructor,\n  type ModelMetadata,\n  EnumModel,\n  ObjectModel,\n} from '@hilla/form';\n\nexport type PropertyType =\n  | 'boolean'\n  | 'date'\n  | 'datetime'\n  | 'decimal'\n  | 'enum'\n  | 'integer'\n  | 'object'\n  | 'string'\n  | 'time'\n  | undefined;\n\nconst javaTypeMap: Record<string, PropertyType> = {\n  byte: 'integer',\n  'java.lang.Byte': 'integer',\n  short: 'integer',\n  'java.lang.Short': 'integer',\n  int: 'integer',\n  'java.lang.Integer': 'integer',\n  long: 'integer',\n  'java.lang.Long': 'integer',\n  float: 'decimal',\n  'java.lang.Float': 'decimal',\n  double: 'decimal',\n  'java.lang.Double': 'decimal',\n  'java.time.LocalDate': 'date',\n  'java.time.LocalTime': 'time',\n  'java.time.LocalDateTime': 'datetime',\n};\n\nfunction determinePropertyType(model: AbstractModel): PropertyType {\n  // Try detecting by Java type\n  const { javaType } = model[_meta];\n  const propertyType = javaType ? javaTypeMap[javaType] : undefined;\n  if (propertyType) {\n    return propertyType;\n  }\n\n  // Otherwise detect by model instance\n  if (model instanceof StringModel) {\n    return 'string';\n  } else if (model instanceof NumberModel) {\n    return 'decimal';\n  } else if (model instanceof BooleanModel) {\n    return 'boolean';\n  } else if (model instanceof EnumModel) {\n    return 'enum';\n  } else if (model instanceof ObjectModel) {\n    return 'object';\n  }\n\n  return undefined;\n}\n\nexport interface PropertyInfo {\n  name: string;\n  humanReadableName: string;\n  type: PropertyType;\n  meta: ModelMetadata;\n  model: AbstractModel;\n}\n\nexport function hasAnnotation(meta: ModelMetadata, annotationName: string): boolean {\n  return meta.annotations?.some((annotation) => annotation.name === annotationName) ?? false;\n}\n\n// This is from vaadin-grid-column.js, should be used from there maybe. At least we must be 100% sure to match grid and fields\nexport function _generateHeader(path: string): string {\n  return path\n    .substring(path.lastIndexOf('.') + 1)\n    .replace(/([A-Z])/gu, '-$1')\n    .toLowerCase()\n    .replace(/-/gu, ' ')\n    .replace(/^./u, (match) => match.toUpperCase());\n}\n\nconst getPropertyNames = (model: DetachedModelConstructor<AbstractModel>): string[] => {\n  const propertyNames: string[] = [];\n\n  for (let proto = model; proto !== ObjectModel; proto = Object.getPrototypeOf(proto)) {\n    // parent properties are added at the beginning\n    propertyNames.unshift(...Object.keys(Object.getOwnPropertyDescriptors(proto.prototype)).filter((p) => p !== 'new'));\n  }\n\n  return propertyNames;\n};\n\nexport class ModelInfo {\n  private readonly modelInstance: AbstractModel;\n\n  readonly idProperty?: PropertyInfo;\n\n  constructor(model: DetachedModelConstructor<AbstractModel>, idPropertyName?: string) {\n    this.modelInstance = createDetachedModel(model);\n\n    // Try to find id property\n    this.idProperty = ModelInfo.resolveIdProperty(this, idPropertyName);\n  }\n\n  private static resolveIdProperty(modelInfo: ModelInfo, idPropertyName?: string): PropertyInfo | undefined {\n    // Return explicit property if defined\n    if (idPropertyName) {\n      return modelInfo.getProperty(idPropertyName);\n    }\n\n    // Otherwise check defaults\n    const rootProperties = modelInfo.getRootProperties();\n    // Check for @Id annotation\n    let idProperty = rootProperties.find((propertyInfo) => hasAnnotation(propertyInfo.meta, 'jakarta.persistence.Id'));\n    // Check for id name as fallback\n    if (!idProperty) {\n      idProperty = rootProperties.find((propertyInfo) => propertyInfo.name === 'id');\n    }\n\n    return idProperty;\n  }\n\n  private static resolvePropertyModel(modelInstance: AbstractModel, path: string): AbstractModel | undefined {\n    const parts = path.split('.');\n    let currentModel: AbstractModel | undefined = modelInstance;\n    for (const part of parts) {\n      if (!currentModel || !(currentModel instanceof ObjectModel)) {\n        return undefined;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      currentModel = (currentModel as any)[part];\n    }\n    return currentModel;\n  }\n\n  getRootProperties(path?: string): PropertyInfo[] {\n    const model = path ? ModelInfo.resolvePropertyModel(this.modelInstance, path) : this.modelInstance;\n    if (!model) {\n      return [];\n    }\n    return getPropertyNames(model.constructor as any)\n      .map((name) => {\n        const effectivePath = path ? `${path}.${name}` : name;\n        return this.getProperty(effectivePath);\n      })\n      .filter(Boolean) as PropertyInfo[];\n  }\n\n  getProperty(path: string): PropertyInfo | undefined {\n    const propertyModel = ModelInfo.resolvePropertyModel(this.modelInstance, path);\n    if (!propertyModel?.[_meta]) {\n      return undefined;\n    }\n\n    const pathParts = path.split('.');\n    const name = pathParts[pathParts.length - 1];\n\n    const meta = propertyModel[_meta];\n    const humanReadableName = _generateHeader(name);\n    const type = determinePropertyType(propertyModel);\n\n    return {\n      name: path,\n      humanReadableName,\n      type,\n      meta,\n      model: propertyModel,\n    };\n  }\n\n  getProperties(paths: string[]): PropertyInfo[] {\n    return paths.map((path) => this.getProperty(path)).filter(Boolean) as PropertyInfo[];\n  }\n}\n\nexport function getDefaultProperties(modelInfo: ModelInfo): PropertyInfo[] {\n  // Start from root properties\n  const properties = modelInfo.getRootProperties();\n  return (\n    properties\n      // Auto-expand nested properties of one-to-one relations\n      .flatMap((prop) => {\n        if (hasAnnotation(prop.meta, 'jakarta.persistence.OneToOne')) {\n          return modelInfo.getRootProperties(prop.name);\n        }\n        return prop;\n      })\n      // Exclude properties that have an unknown type, or are annotated with id\n      // and version\n      .filter(\n        (prop) =>\n          !!prop.type &&\n          !(\n            hasAnnotation(prop.meta, 'jakarta.persistence.Id') ||\n            hasAnnotation(prop.meta, 'jakarta.persistence.Version')\n          ),\n      )\n  );\n}\n"],
  "mappings": "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",
  "names": []
}
