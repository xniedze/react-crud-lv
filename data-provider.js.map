{
  "version": 3,
  "sources": ["src/data-provider.ts"],
  "sourcesContent": ["import type { GridDataProviderCallback, GridDataProviderParams } from '@vaadin/react-components/Grid';\nimport type { GridDataProvider } from '@vaadin/react-components/Grid';\nimport { useMemo, useState } from 'react';\nimport type { CountService, ListService } from './crud';\nimport type FilterUnion from './types/com/vaadin/hilla/crud/filter/FilterUnion';\nimport type Sort from './types/com/vaadin/hilla/mappedtypes/Sort';\nimport Direction from './types/org/springframework/data/domain/Sort/Direction';\n\ntype MaybeCountService<TItem> = Partial<CountService<TItem>>;\ntype ListAndMaybeCountService<TItem> = ListService<TItem> & MaybeCountService<TItem>;\ntype ListAndCountService<TItem> = CountService<TItem> & ListService<TItem>;\n\ntype PageRequest = {\n  pageNumber: number;\n  pageSize: number;\n  sort: Sort;\n};\n\ntype DataPage<TItem> = {\n  items: TItem[];\n  pageRequest: PageRequest;\n};\n\nexport type ItemCounts = {\n  totalCount?: number;\n  filteredCount?: number;\n};\n\ntype AfterLoadCallback = (result: ItemCounts) => void;\n\ntype DataProviderOptions = {\n  initialFilter?: FilterUnion;\n  loadTotalCount?: boolean;\n  afterLoad?: AfterLoadCallback;\n};\n\nfunction createSort<TItem>(params: GridDataProviderParams<TItem>): Sort {\n  return {\n    orders: params.sortOrders\n      .filter((order) => order.direction != null)\n      .map((order) => ({\n        property: order.path,\n        direction: order.direction === 'asc' ? Direction.ASC : Direction.DESC,\n        ignoreCase: false,\n      })),\n  };\n}\n\nexport function isCountService<TItem>(service: ListAndMaybeCountService<TItem>): service is ListAndCountService<TItem> {\n  return !!service.count;\n}\n\nexport abstract class DataProvider<TItem> {\n  protected readonly service: ListAndMaybeCountService<TItem>;\n  protected readonly loadTotalCount?: boolean;\n  protected readonly afterLoadCallback?: AfterLoadCallback;\n\n  protected filter: FilterUnion | undefined;\n  protected totalCount: number | undefined;\n  protected filteredCount: number | undefined;\n\n  constructor(service: ListAndMaybeCountService<TItem>, options: DataProviderOptions = {}) {\n    this.service = service;\n    this.filter = options.initialFilter;\n    this.loadTotalCount = options.loadTotalCount;\n    this.afterLoadCallback = options.afterLoad;\n\n    this.load = this.load.bind(this);\n  }\n\n  reset(): void {\n    this.totalCount = undefined;\n    this.filteredCount = undefined;\n  }\n\n  setFilter(filter: FilterUnion | undefined): void {\n    this.reset();\n    this.filter = filter;\n  }\n\n  async load(params: GridDataProviderParams<TItem>, callback: GridDataProviderCallback<TItem>): Promise<void> {\n    // Fetch page and filtered count\n    const page = await this.fetchPage(params);\n    this.filteredCount = await this.fetchFilteredCount(page);\n    // Only fetch total count if it's specific in options\n    if (this.loadTotalCount) {\n      this.totalCount = await this.fetchTotalCount(page);\n    }\n\n    // Pass results to grid\n    callback(page.items, this.filteredCount);\n\n    // Pass results to callback\n    if (this.afterLoadCallback) {\n      this.afterLoadCallback({\n        totalCount: this.totalCount,\n        filteredCount: this.filteredCount,\n      });\n    }\n  }\n\n  protected async fetchPage(params: GridDataProviderParams<TItem>): Promise<DataPage<TItem>> {\n    const sort = createSort(params);\n    const pageNumber = params.page;\n    const { pageSize } = params;\n    const pageRequest = {\n      pageNumber,\n      pageSize,\n      sort,\n    };\n    const items = await this.service.list(pageRequest, this.filter);\n\n    return { items, pageRequest };\n  }\n\n  protected abstract fetchTotalCount(page: DataPage<TItem>): Promise<number | undefined> | number | undefined;\n\n  protected abstract fetchFilteredCount(page: DataPage<TItem>): Promise<number | undefined> | number | undefined;\n}\n\nexport class InfiniteDataProvider<TItem> extends DataProvider<TItem> {\n  // cannot be static, otherwise it does not implement superclass\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  protected fetchTotalCount(): undefined {\n    return undefined;\n  }\n\n  protected fetchFilteredCount(page: DataPage<TItem>): number | undefined {\n    const { items, pageRequest } = page;\n    const { pageNumber, pageSize } = pageRequest;\n    let infiniteScrollingSize;\n\n    if (items.length === pageSize) {\n      infiniteScrollingSize = (pageNumber + 1) * pageSize + 1;\n      if (this.filteredCount !== undefined && infiniteScrollingSize < this.filteredCount) {\n        // Only allow size to grow here to avoid shrinking the size when scrolled down and sorting\n        infiniteScrollingSize = this.filteredCount;\n      }\n    } else {\n      infiniteScrollingSize = pageNumber * pageSize + items.length;\n    }\n\n    return infiniteScrollingSize;\n  }\n}\n\nexport class FixedSizeDataProvider<TItem> extends DataProvider<TItem> {\n  declare service: ListAndCountService<TItem>;\n\n  constructor(service: ListAndMaybeCountService<TItem>, options: DataProviderOptions = {}) {\n    if (!isCountService(service)) {\n      throw new Error('The provided service does not implement the CountService interface.');\n    }\n    super(service, options);\n  }\n\n  protected async fetchTotalCount(): Promise<number | undefined> {\n    // Use cached count if it's already known\n    if (this.totalCount !== undefined) {\n      return this.totalCount;\n    }\n    return this.service.count(undefined);\n  }\n\n  protected async fetchFilteredCount(): Promise<number | undefined> {\n    // Use cached count if it's already known\n    if (this.filteredCount !== undefined) {\n      return this.filteredCount;\n    }\n    return this.service.count(this.filter);\n  }\n}\n\nexport function createDataProvider<TItem>(\n  service: ListAndMaybeCountService<TItem>,\n  options: DataProviderOptions = {},\n): DataProvider<TItem> {\n  if (isCountService(service)) {\n    return new FixedSizeDataProvider(service, options);\n  }\n  return new InfiniteDataProvider(service, options);\n}\n\ntype UseDataProviderResult<TItem> = Readonly<{\n  dataProvider: GridDataProvider<TItem>;\n  refresh(): void;\n}>;\n\nexport function useDataProvider<TItem>(\n  service: ListAndMaybeCountService<TItem>,\n  filter?: FilterUnion,\n): UseDataProviderResult<TItem> {\n  const [refreshCounter, setRefreshCounter] = useState(0);\n  const dataProvider = useMemo(() => createDataProvider(service, { initialFilter: filter }), [service]);\n\n  // Update filter in data provider\n  dataProvider.setFilter(filter);\n\n  // Create a new data provider function reference when the filter changes or the refresh counter is incremented.\n  // This effectively forces the grid to reload\n  const dataProviderFn = useMemo(() => dataProvider.load.bind(dataProvider), [dataProvider, filter, refreshCounter]);\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    dataProvider: dataProviderFn,\n    refresh: () => {\n      dataProvider.reset();\n      setRefreshCounter(refreshCounter + 1);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
