{
  "version": 3,
  "sources": ["src/autogrid.tsx"],
  "sourcesContent": ["import type { AbstractModel, DetachedModelConstructor } from '@vaadin/hilla-lit-form';\nimport { Grid, type GridElement, type GridProps } from '@vaadin/react-components/Grid.js';\nimport { GridColumn } from '@vaadin/react-components/GridColumn.js';\nimport { GridColumnGroup } from '@vaadin/react-components/GridColumnGroup.js';\nimport {\n  cloneElement,\n  type ComponentType,\n  type ForwardedRef,\n  forwardRef,\n  type JSX,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { ColumnContext, CustomColumnContext, type SortState } from './autogrid-column-context.js';\nimport { type ColumnOptions, getColumnOptions } from './autogrid-columns.js';\nimport { AutoGridFooterItemCountRenderer, AutoGridRowNumberRenderer, FooterContext } from './autogrid-renderers.js';\nimport css from './autogrid.obj.js';\nimport type { ListService } from './crud';\nimport { createDataProvider, type DataProvider, isCountService, type ItemCounts } from './data-provider.js';\nimport { type HeaderFilterRendererProps, NoHeaderFilter, HeaderFilterWrapper } from './header-filter';\nimport { HeaderSorter } from './header-sorter';\nimport { getDefaultProperties, ModelInfo, type PropertyInfo } from './model-info.js';\nimport type AndFilter from './types/com/vaadin/hilla/crud/filter/AndFilter.js';\nimport type FilterUnion from './types/com/vaadin/hilla/crud/filter/FilterUnion.js';\nimport { isFilterEmpty, registerStylesheet } from './util';\n\nregisterStylesheet(css);\n\nexport interface AutoGridRef<TItem = any> {\n  /**\n   * The underlying vaadin-grid DOM element.\n   */\n  grid: GridElement<TItem> | null;\n\n  /**\n   * Refreshes the grid by reloading the data from the backend.\n   */\n  refresh(): void;\n}\n\ninterface AutoGridOwnProps<TItem> {\n  /**\n   * The service to use for fetching the data. This must be a TypeScript service\n   * that has been generated by Hilla from a backend Java service that\n   * implements the `com.vaadin.hilla.crud.ListService` interface.\n   */\n  service: ListService<TItem>;\n  /**\n   * The entity model to use for the grid, which determines which columns to\n   * show and how to render them. This must be a Typescript model class that has\n   * been generated by Hilla from a backend Java class. The model must match\n   * with the type of the items returned by the service. For example, a\n   * `PersonModel` can be used with a service that returns `Person` instances.\n   *\n   * By default, the grid shows columns for all properties of the model which\n   * have a type that is supported. Use the `visibleColumns` option to customize\n   * which columns to show and in which order.\n   */\n  model: DetachedModelConstructor<AbstractModel<TItem>>;\n  /**\n   * The property to use to detect an item's ID. The item ID is used to keep\n   * the selection state when reloading the grid.\n   *\n   * By default, the component uses the property annotated with\n   * `jakarta.persistence.Id`, or a property named `id`, in that order.\n   * This option can be used to override the default behavior, or define the ID\n   * property in case a class doesn't have a property matching the defaults.\n   */\n  itemIdProperty?: string;\n  /**\n   * Allows to provide a filter that is applied when fetching data from the\n   * service. This can be used for implementing an external filter UI outside\n   * the grid. A custom filter is not compatible with header filters.\n   *\n   * **NOTE:** This is considered an experimental feature and the API may change\n   * in the future.\n   */\n  experimentalFilter?: FilterUnion;\n  /**\n   * Allows to customize which columns to show and in which order. This must be\n   * an array of property names that are defined in the model. Nested properties\n   * can be specified using dot notation, e.g. `address.street`.\n   */\n  visibleColumns?: string[];\n  /**\n   * Allows to customize which columns to hide. This must be an array of property\n   * names that are defined in the model. Nested properties can be specified using\n   * dot notation, e.g. `address.street`.\n   */\n  hiddenColumns?: string[];\n  /**\n   * Disables header filters, which are otherwise enabled by default.\n   */\n  noHeaderFilters?: boolean;\n  /**\n   * Allows to add custom columns to the grid. This must be an array of\n   * `GridColumn` component instances. Custom columns are added after the\n   * auto-generated columns.\n   */\n  customColumns?: JSX.Element[];\n  /**\n   * Allows to customize the props for individual columns. This is an object\n   * where the keys must be property names that are defined in the model, and\n   * the values are props that are accepted by the `GridColumn` component.\n   * Nested properties can be specified using dot notation, e.g.\n   * `address.street`.\n   */\n  columnOptions?: Record<string, ColumnOptions>;\n  /**\n   * When enabled, inserts a column with row numbers at the beginning of the\n   * grid.\n   */\n  rowNumbers?: boolean;\n  /**\n   * When enabled, shows the total count of items in the grid footer.\n   * This requires the provided service to implement the CountService interface,\n   *  otherwise an error will be logged to the console, without any count being\n   *  rendered.\n   */\n  totalCount?: boolean;\n  /**\n   * When enabled, shows the filtered item count in the grid footer.\n   * if totalCount is also enabled, it will show both totalCount and filteredCount.\n   * This requires the provided service to implement the CountService interface,\n   *  otherwise an error will be logged to the console, without any count being\n   *  rendered.\n   */\n  filteredCount?: boolean;\n  /**\n   * Allows to customize the grid footer with a custom renderer component for\n   *  the total count and filtered item count.\n   * This requires the provided service to implement the CountService interface,\n   * See {@link AutoGrid#totalCount} and {@link AutoGrid#filteredCount}.\n   */\n  footerCountRenderer?: ComponentType<ItemCounts>;\n}\n\nexport type AutoGridProps<TItem> = GridProps<TItem> & Readonly<AutoGridOwnProps<TItem>>;\n\ninterface ColumnConfigurationOptions {\n  visibleColumns?: string[];\n  hiddenColumns?: string[];\n  noHeaderFilters?: boolean;\n  customColumns?: JSX.Element[];\n  columnOptions?: Record<string, ColumnOptions>;\n  rowNumbers?: boolean;\n  totalCount?: boolean;\n  filteredCount?: boolean;\n  footerCountRenderer?: ComponentType<ItemCounts>;\n  itemCounts?: ItemCounts;\n}\n\nfunction wrapCustomColumn(\n  column: JSX.Element,\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n  options: ColumnConfigurationOptions,\n) {\n  const key = column.key ?? 'no-key';\n  const { header, headerRenderer } = column.props;\n  const customOptions = options.columnOptions?.[key];\n  const { header: customHeader, headerRenderer: customHeaderRenderer, headerFilterRenderer } = customOptions ?? {};\n  const columnWithoutHeader = cloneElement(column, {\n    header: null,\n    headerRenderer: HeaderFilterWrapper,\n  });\n  return (\n    <CustomColumnContext.Provider\n      key={key}\n      value={{\n        setColumnFilter,\n        headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,\n        filterKey: key,\n      }}\n    >\n      <GridColumnGroup\n        key={key}\n        header={customHeader ?? header}\n        headerRenderer={customHeaderRenderer ?? headerRenderer}\n      >\n        {columnWithoutHeader}\n      </GridColumnGroup>\n    </CustomColumnContext.Provider>\n  );\n}\n\nfunction addCustomColumns(\n  columns: JSX.Element[],\n  options: ColumnConfigurationOptions,\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n): JSX.Element[] {\n  if (!options.customColumns) {\n    return columns;\n  }\n\n  // When using header filters, wrap custom columns into column groups and\n  // move header text or renderer to group\n  const customColumns = options.noHeaderFilters\n    ? options.customColumns\n    : options.customColumns.map((column) => wrapCustomColumn(column, setColumnFilter, options));\n\n  // When using a custom column order, insert custom columns into auto-generated\n  // ones using their `key`\n  if (options.visibleColumns) {\n    const columnMap = [...columns, ...customColumns].reduce((map, column) => {\n      const { key } = column;\n      if (key) {\n        map.set(key, column);\n      }\n      return map;\n    }, new Map<string, JSX.Element>());\n\n    return options.visibleColumns.map((path) => columnMap.get(path)).filter(Boolean) as JSX.Element[];\n  }\n\n  // Otherwise just append custom columns at the end\n  return [...columns, ...customColumns];\n}\n\nfunction useColumns(\n  properties: PropertyInfo[],\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n  options: ColumnConfigurationOptions,\n) {\n  const sortableProperties = properties.filter(\n    (propertyInfo) => options.columnOptions?.[propertyInfo.name]?.sortable !== false,\n  );\n  const [sortState, setSortState] = useState<SortState>(\n    sortableProperties.length > 0 ? { [sortableProperties[0].name]: { direction: 'asc' } } : {},\n  );\n  let columns = properties.map((propertyInfo) => {\n    let column;\n    const customColumnOptions = options.columnOptions?.[propertyInfo.name];\n\n    const { headerFilterRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);\n\n    if (!options.noHeaderFilters) {\n      column = (\n        <GridColumnGroup headerRenderer={HeaderSorter}>\n          <GridColumn path={propertyInfo.name} headerRenderer={HeaderFilterWrapper} {...columnProps}></GridColumn>\n        </GridColumnGroup>\n      );\n    } else {\n      column = <GridColumn path={propertyInfo.name} headerRenderer={HeaderSorter} {...columnProps}></GridColumn>;\n    }\n    return (\n      <ColumnContext.Provider\n        key={propertyInfo.name}\n        value={{\n          propertyInfo,\n          setColumnFilter,\n          sortState,\n          setSortState,\n          customColumnOptions,\n          headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,\n          filterKey: propertyInfo.name,\n        }}\n      >\n        {column}\n      </ColumnContext.Provider>\n    );\n  });\n\n  columns = addCustomColumns(columns, options, setColumnFilter);\n\n  // When using `hiddenColumns` option, remove columns to hide using their `key`\n  if (options.hiddenColumns) {\n    columns = columns.filter(({ key }) => !(key && options.hiddenColumns?.includes(key)));\n  }\n\n  if (options.rowNumbers) {\n    columns = [\n      <GridColumn key=\"rownumbers\" width=\"4em\" flexGrow={0} renderer={AutoGridRowNumberRenderer}></GridColumn>,\n      ...columns,\n    ];\n  }\n  const { totalCount, filteredCount, itemCounts, footerCountRenderer } = options;\n  if (totalCount ?? filteredCount) {\n    const col = (\n      <FooterContext.Provider\n        key=\"grid-footer\"\n        value={{\n          totalCount,\n          filteredCount,\n          footerCountRenderer,\n          itemCounts,\n        }}\n      >\n        <GridColumnGroup footerRenderer={AutoGridFooterItemCountRenderer}>{columns}</GridColumnGroup>\n      </FooterContext.Provider>\n    );\n    columns = [col];\n  }\n\n  return columns;\n}\n\nfunction AutoGridInner<TItem>(\n  {\n    service,\n    model,\n    itemIdProperty,\n    experimentalFilter,\n    visibleColumns,\n    hiddenColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n    totalCount,\n    filteredCount,\n    footerCountRenderer,\n    ...gridProps\n  }: AutoGridProps<TItem>,\n  ref: ForwardedRef<AutoGridRef<TItem>>,\n): JSX.Element {\n  const [internalFilter, setInternalFilter] = useState<AndFilter>({ '@type': 'and', children: [] });\n  const [itemCounts, setItemCounts] = useState<ItemCounts | undefined>();\n  const gridRef = useRef<GridElement<TItem>>(null);\n  const dataProviderRef = useRef<DataProvider<TItem>>();\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      get grid() {\n        return gridRef.current;\n      },\n      refresh() {\n        dataProviderRef.current?.reset();\n        gridRef.current?.clearCache();\n      },\n    }),\n    [],\n  );\n\n  const setHeaderFilter = (filter: FilterUnion, filterKey: string) => {\n    let changed = false;\n    filter.key = filterKey;\n    const indexOfFilter = filterKey\n      ? internalFilter.children.findIndex((f) => (f as FilterUnion).key === filterKey)\n      : -1;\n    const isEmptyFilter = isFilterEmpty(filter);\n\n    if (indexOfFilter >= 0 && isEmptyFilter) {\n      internalFilter.children.splice(indexOfFilter, 1);\n      changed = true;\n    } else if (!isEmptyFilter) {\n      if (indexOfFilter >= 0) {\n        internalFilter.children[indexOfFilter] = filter;\n        changed = true;\n      } else {\n        internalFilter.children.push(filter);\n        changed = true;\n      }\n    }\n    if (changed) {\n      setInternalFilter({ ...internalFilter });\n    }\n  };\n\n  const modelInfo = useMemo(() => new ModelInfo(model, itemIdProperty), [model]);\n  const properties = visibleColumns ? modelInfo.getProperties(visibleColumns) : getDefaultProperties(modelInfo);\n  const children = useColumns(properties, setHeaderFilter, {\n    visibleColumns,\n    hiddenColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n    totalCount,\n    filteredCount,\n    footerCountRenderer,\n    itemCounts,\n  });\n\n  useEffect(() => {\n    // Remove all filtering if header filters are removed\n    if (noHeaderFilters) {\n      setInternalFilter({ '@type': 'and', children: [] });\n    }\n  }, [noHeaderFilters]);\n\n  useEffect(() => {\n    // Log an error if totalCount or filteredCount is enabled but the service doesn't implement CountService\n    if ((!isCountService(service) && totalCount) ?? filteredCount) {\n      console.error(\n        '\"totalCount\" and \"filteredCount\" props require the provided service to implement the CountService interface.',\n      );\n    }\n    // Sets the data provider, should be done only once\n    const grid = gridRef.current!;\n    // Wait for the sorting headers to be rendered so that the sorting state is correct for the first data provider call\n    const timeoutId = setTimeout(() => {\n      let firstUpdate = true;\n      const dataProvider = createDataProvider(service, {\n        initialFilter: experimentalFilter ?? internalFilter,\n        loadTotalCount: totalCount,\n        afterLoad(newItemCounts: ItemCounts) {\n          setItemCounts(newItemCounts);\n\n          if (firstUpdate) {\n            // Workaround for https://github.com/vaadin/react-components/issues/129\n            firstUpdate = false;\n            setTimeout(() => grid.recalculateColumnWidths(), 0);\n          }\n        },\n      });\n      dataProviderRef.current = dataProvider;\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      gridRef.current!.dataProvider = dataProvider.load.bind(dataProvider);\n    }, 1);\n\n    return () => clearTimeout(timeoutId);\n  }, [model, service]);\n\n  useEffect(() => {\n    // Update the filtering, whenever the filter changes\n    const dataProvider = dataProviderRef.current;\n    const grid = gridRef.current;\n    if (grid && dataProvider) {\n      dataProvider.setFilter(experimentalFilter ?? internalFilter);\n      grid.clearCache();\n    }\n  }, [experimentalFilter, internalFilter]);\n\n  return (\n    <Grid itemIdPath={modelInfo.idProperty?.name} {...gridProps} ref={gridRef}>\n      {children}\n    </Grid>\n  );\n}\n\ntype AutoGrid = <TItem>(\n  props: AutoGridProps<TItem> & { ref?: ForwardedRef<AutoGridRef<TItem>> },\n) => ReturnType<typeof AutoGridInner>;\n\n/**\n * Auto Grid is a component for displaying tabular data based on a Java backend\n * service. It automatically generates columns based on the properties of a\n * Java class and provides features such as lazy-loading, sorting and filtering.\n *\n * Example usage:\n * ```tsx\n * import { AutoGrid } from '@vaadin/hilla-react-crud';\n * import PersonService from 'Frontend/generated/endpoints';\n * import PersonModel from 'Frontend/generated/com/example/application/Person';\n *\n * <AutoGrid service={PersonService} model={PersonModel} />\n * ```\n */\nexport const AutoGrid: AutoGrid = forwardRef(AutoGridInner) as AutoGrid;\n\nexport type { ColumnOptions, HeaderFilterRendererProps };\n"],
  "mappings": "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",
  "names": []
}
