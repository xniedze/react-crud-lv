{
  "version": 3,
  "sources": ["src/autogrid.tsx"],
  "sourcesContent": ["import type { AbstractModel, DetachedModelConstructor } from '@hilla/form';\nimport {\n  Grid,\n  type GridDataProvider,\n  type GridDataProviderCallback,\n  type GridDataProviderParams,\n  type GridDefaultItem,\n  type GridElement,\n  type GridProps,\n} from '@hilla/react-components/Grid.js';\nimport { GridColumn } from '@hilla/react-components/GridColumn.js';\nimport { GridColumnGroup } from '@hilla/react-components/GridColumnGroup.js';\nimport {\n  type ForwardedRef,\n  forwardRef,\n  type JSX,\n  type MutableRefObject,\n  useEffect,\n  useMemo,\n  useImperativeHandle,\n  useRef,\n  useState,\n  cloneElement,\n} from 'react';\nimport { ColumnContext, type SortState } from './autogrid-column-context.js';\nimport { type ColumnOptions, getColumnOptions } from './autogrid-columns.js';\nimport { AutoGridRowNumberRenderer } from './autogrid-renderers.js';\nimport css from './autogrid.obj.js';\nimport type { ListService } from './crud';\nimport { HeaderSorter } from './header-sorter';\nimport { getDefaultProperties, ModelInfo, type PropertyInfo } from './model-info.js';\nimport type AndFilter from './types/dev/hilla/crud/filter/AndFilter.js';\nimport type FilterUnion from './types/dev/hilla/crud/filter/FilterUnion.js';\nimport type PropertyStringFilter from './types/dev/hilla/crud/filter/PropertyStringFilter.js';\nimport type Sort from './types/dev/hilla/mappedtypes/Sort.js';\nimport Direction from './types/org/springframework/data/domain/Sort/Direction.js';\nimport { registerStylesheet } from './util';\n\nregisterStylesheet(css);\n\nexport interface AutoGridRef<TItem = any> {\n  /**\n   * The underlying vaadin-grid DOM element.\n   */\n  grid: GridElement<TItem> | null;\n\n  /**\n   * Refreshes the grid by reloading the data from the backend.\n   */\n  refresh(): void;\n}\n\ninterface AutoGridOwnProps<TItem> {\n  /**\n   * The service to use for fetching the data. This must be a TypeScript service\n   * that has been generated by Hilla from a backend Java service that\n   * implements the `dev.hilla.crud.ListService` interface.\n   */\n  service: ListService<TItem>;\n  /**\n   * The entity model to use for the grid, which determines which columns to\n   * show and how to render them. This must be a Typescript model class that has\n   * been generated by Hilla from a backend Java class. The model must match\n   * with the type of the items returned by the service. For example, a\n   * `PersonModel` can be used with a service that returns `Person` instances.\n   *\n   * By default, the grid shows columns for all properties of the model which\n   * have a type that is supported. Use the `visibleColumns` option to customize\n   * which columns to show and in which order.\n   */\n  model: DetachedModelConstructor<AbstractModel<TItem>>;\n  /**\n   * The property to use to detect an item's ID. The item ID is used to keep\n   * the selection state when reloading the grid.\n   *\n   * By default, the component uses the property annotated with\n   * `jakarta.persistence.Id`, or a property named `id`, in that order.\n   * This option can be used to override the default behavior, or define the ID\n   * property in case a class doesn't have a property matching the defaults.\n   */\n  itemIdProperty?: string;\n  /**\n   * Allows to provide a filter that is applied when fetching data from the\n   * service. This can be used for implementing an external filter UI outside\n   * the grid. A custom filter is not compatible with header filters.\n   *\n   * **NOTE:** This is considered an experimental feature and the API may change\n   * in the future.\n   */\n  experimentalFilter?: FilterUnion;\n  /**\n   * Allows to customize which columns to show and in which order. This must be\n   * an array of property names that are defined in the model. Nested properties\n   * can be specified using dot notation, e.g. `address.street`.\n   */\n  visibleColumns?: string[];\n  /**\n   * Disables header filters, which are otherwise enabled by default.\n   */\n  noHeaderFilters?: boolean;\n  /**\n   * Allows to add custom columns to the grid. This must be an array of\n   * `GridColumn` component instances. Custom columns are added after the\n   * auto-generated columns.\n   */\n  customColumns?: JSX.Element[];\n  /**\n   * Allows to customize the props for individual columns. This is an object\n   * where the keys must be property names that are defined in the model, and\n   * the values are props that are accepted by the `GridColumn` component.\n   * Nested properties can be specified using dot notation, e.g.\n   * `address.street`.\n   */\n  columnOptions?: Record<string, ColumnOptions>;\n  /**\n   * When enabled, inserts a column with row numbers at the beginning of the\n   * grid.\n   */\n  rowNumbers?: boolean;\n}\n\nexport type AutoGridProps<TItem> = GridProps<TItem> & Readonly<AutoGridOwnProps<TItem>>;\n\ntype GridElementWithInternalAPI<TItem = GridDefaultItem> = GridElement<TItem> &\n  Readonly<{\n    _dataProviderController: {\n      rootCache: {\n        size?: number;\n      };\n    };\n  }>;\n\nfunction createDataProvider<TItem>(\n  grid: GridElement<TItem>,\n  service: ListService<TItem>,\n  filter: MutableRefObject<FilterUnion | undefined>,\n): GridDataProvider<TItem> {\n  let first = true;\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  return async (params: GridDataProviderParams<TItem>, callback: GridDataProviderCallback<TItem>) => {\n    const sort: Sort = {\n      orders: params.sortOrders\n        .filter((order) => order.direction != null)\n        .map((order) => ({\n          property: order.path,\n          direction: order.direction === 'asc' ? Direction.ASC : Direction.DESC,\n          ignoreCase: false,\n        })),\n    };\n\n    const pageNumber = params.page;\n    const { pageSize } = params;\n    const req = {\n      pageNumber,\n      pageSize,\n      sort,\n    };\n\n    const items = await service.list(req, filter.current);\n    let size;\n    if (items.length === pageSize) {\n      size = (pageNumber + 1) * pageSize + 1;\n\n      const cacheSize = (grid as GridElementWithInternalAPI<TItem>)._dataProviderController.rootCache.size;\n      if (cacheSize !== undefined && size < cacheSize) {\n        // Only allow size to grow here to avoid shrinking the size when scrolled down and sorting\n        size = undefined;\n      }\n    } else {\n      size = pageNumber * pageSize + items.length;\n    }\n    callback(items, size);\n    if (first) {\n      // Workaround for https://github.com/vaadin/react-components/issues/129\n      first = false;\n      setTimeout(() => grid.recalculateColumnWidths(), 0);\n    }\n  };\n}\n\ninterface ColumnConfigurationOptions {\n  visibleColumns?: string[];\n  noHeaderFilters?: boolean;\n  customColumns?: JSX.Element[];\n  columnOptions?: Record<string, ColumnOptions>;\n  rowNumbers?: boolean;\n}\n\nfunction addCustomColumns(columns: JSX.Element[], options: ColumnConfigurationOptions): JSX.Element[] {\n  if (!options.customColumns) {\n    return columns;\n  }\n\n  // When using header filters, wrap custom columns into column groups and\n  // move header text or renderer to group\n  const customColumns = options.noHeaderFilters\n    ? options.customColumns\n    : options.customColumns.map((column) => {\n        const { header, headerRenderer } = column.props;\n        const { key } = column;\n        const columnWithoutHeader = cloneElement(column, { header: undefined, headerRenderer: undefined });\n        return (\n          <GridColumnGroup key={key} header={header} headerRenderer={headerRenderer}>\n            {columnWithoutHeader}\n          </GridColumnGroup>\n        );\n      });\n\n  // When using a custom column order, insert custom columns into auto-generated\n  // ones using their `key`\n  if (options.visibleColumns) {\n    const columnMap = [...columns, ...customColumns].reduce((map, column) => {\n      const { key } = column;\n      if (key) {\n        map.set(key, column);\n      }\n      return map;\n    }, new Map<string, JSX.Element>());\n\n    return options.visibleColumns.map((path) => columnMap.get(path)).filter(Boolean) as JSX.Element[];\n  }\n\n  // Otherwise just append custom columns at the end\n  return [...columns, ...customColumns];\n}\n\nfunction useColumns(\n  properties: PropertyInfo[],\n  setPropertyFilter: (propertyFilter: PropertyStringFilter) => void,\n  options: ColumnConfigurationOptions,\n) {\n  const sortableProperties = properties.filter(\n    (propertyInfo) => options.columnOptions?.[propertyInfo.name]?.sortable !== false,\n  );\n  const [sortState, setSortState] = useState<SortState>(\n    sortableProperties.length > 0 ? { [sortableProperties[0].name]: { direction: 'asc' } } : {},\n  );\n\n  let columns = properties.map((propertyInfo) => {\n    let column;\n\n    const customColumnOptions = options.columnOptions ? options.columnOptions[propertyInfo.name] : undefined;\n\n    // Header renderer is effectively the header filter, which should only be\n    // applied when header filters are enabled\n    const { headerRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);\n\n    if (!options.noHeaderFilters) {\n      column = (\n        <GridColumnGroup headerRenderer={HeaderSorter}>\n          <GridColumn path={propertyInfo.name} headerRenderer={headerRenderer} {...columnProps}></GridColumn>\n        </GridColumnGroup>\n      );\n    } else {\n      column = <GridColumn path={propertyInfo.name} headerRenderer={HeaderSorter} {...columnProps}></GridColumn>;\n    }\n    return (\n      <ColumnContext.Provider\n        key={propertyInfo.name}\n        value={{\n          propertyInfo,\n          setPropertyFilter,\n          sortState,\n          setSortState,\n          customColumnOptions,\n        }}\n      >\n        {column}\n      </ColumnContext.Provider>\n    );\n  });\n\n  columns = addCustomColumns(columns, options);\n\n  if (options.rowNumbers) {\n    columns = [\n      <GridColumn key=\"rownumbers\" width=\"4em\" flexGrow={0} renderer={AutoGridRowNumberRenderer}></GridColumn>,\n      ...columns,\n    ];\n  }\n\n  return columns;\n}\n\nfunction AutoGridInner<TItem>(\n  {\n    service,\n    model,\n    itemIdProperty,\n    experimentalFilter,\n    visibleColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n    ...gridProps\n  }: AutoGridProps<TItem>,\n  ref: ForwardedRef<AutoGridRef<TItem>>,\n): JSX.Element {\n  const [internalFilter, setInternalFilter] = useState<AndFilter>({ '@type': 'and', children: [] });\n  const gridRef = useRef<GridElement<TItem>>(null);\n  const dataProviderFilter = useRef<FilterUnion | undefined>(undefined);\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      get grid() {\n        return gridRef.current;\n      },\n      refresh() {\n        gridRef.current?.clearCache();\n      },\n    }),\n    [],\n  );\n\n  const setHeaderPropertyFilter = (propertyFilter: PropertyStringFilter) => {\n    const filterIndex = internalFilter.children.findIndex(\n      (f) => (f as PropertyStringFilter).propertyId === propertyFilter.propertyId,\n    );\n    let changed = false;\n    if (propertyFilter.filterValue === '') {\n      // Delete empty filter\n      if (filterIndex >= 0) {\n        internalFilter.children.splice(filterIndex, 1);\n        changed = true;\n      }\n    } else if (filterIndex >= 0) {\n      internalFilter.children[filterIndex] = propertyFilter;\n      changed = true;\n    } else {\n      internalFilter.children.push(propertyFilter);\n      changed = true;\n    }\n    if (changed) {\n      setInternalFilter({ ...internalFilter });\n    }\n  };\n\n  const modelInfo = useMemo(() => new ModelInfo(model, itemIdProperty), [model]);\n  const properties = visibleColumns ? modelInfo.getProperties(visibleColumns) : getDefaultProperties(modelInfo);\n  const children = useColumns(properties, setHeaderPropertyFilter, {\n    visibleColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n  });\n\n  useEffect(() => {\n    // Remove all filtering if header filters are removed\n    if (noHeaderFilters) {\n      setInternalFilter({ '@type': 'and', children: [] });\n    }\n  }, [noHeaderFilters]);\n\n  useEffect(() => {\n    // Sets the data provider, should be done only once\n    const grid = gridRef.current!;\n    setTimeout(() => {\n      // Wait for the sorting headers to be rendered so that the sorting state is correct for the first data provider call\n      grid.dataProvider = createDataProvider(grid, service, dataProviderFilter);\n    }, 1);\n  }, [model, service]);\n\n  useEffect(() => {\n    // Update the filtering, whenever the filter changes\n    const grid = gridRef.current;\n    if (grid) {\n      dataProviderFilter.current = experimentalFilter ?? internalFilter;\n      grid.clearCache();\n    }\n  }, [experimentalFilter, internalFilter]);\n\n  return (\n    <Grid itemIdPath={modelInfo.idProperty?.name} {...gridProps} ref={gridRef}>\n      {children}\n    </Grid>\n  );\n}\n\ntype AutoGrid = <TItem>(\n  props: AutoGridProps<TItem> & { ref?: ForwardedRef<AutoGridRef<TItem>> },\n) => ReturnType<typeof AutoGridInner>;\n\n/**\n * Auto Grid is a component for displaying tabular data based on a Java backend\n * service. It automatically generates columns based on the properties of a\n * Java class and provides features such as lazy-loading, sorting and filtering.\n *\n * Example usage:\n * ```tsx\n * import { AutoGrid } from '@hilla/react-crud';\n * import PersonService from 'Frontend/generated/endpoints';\n * import PersonModel from 'Frontend/generated/com/example/application/Person';\n *\n * <AutoGrid service={PersonService} model={PersonModel} />\n * ```\n */\nexport const AutoGrid: AutoGrid = forwardRef(AutoGridInner) as AutoGrid;\n"],
  "mappings": "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",
  "names": []
}
