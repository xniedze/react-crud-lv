{
  "version": 3,
  "sources": ["src/autoform-field.tsx"],
  "sourcesContent": ["import { _enum, type AbstractModel, type EnumModel, type Validator } from '@vaadin/hilla-lit-form';\nimport type { FieldDirectiveResult, UseFormResult } from '@vaadin/hilla-react-form';\nimport { useFormPart } from '@vaadin/hilla-react-form';\nimport { Checkbox } from '@vaadin/react-components/Checkbox.js';\nimport { DatePicker } from '@vaadin/react-components/DatePicker.js';\nimport { DateTimePicker } from '@vaadin/react-components/DateTimePicker.js';\nimport { IntegerField } from '@vaadin/react-components/IntegerField.js';\nimport { NumberField } from '@vaadin/react-components/NumberField.js';\nimport { Select } from '@vaadin/react-components/Select.js';\nimport { TextArea } from '@vaadin/react-components/TextArea.js';\nimport { TextField } from '@vaadin/react-components/TextField.js';\nimport { TimePicker } from '@vaadin/react-components/TimePicker.js';\nimport {\n  cloneElement,\n  type ComponentType,\n  createElement,\n  type CSSProperties,\n  type JSX,\n  useEffect,\n  useMemo,\n} from 'react';\nimport { useDatePickerI18n, useDateTimePickerI18n } from './locale.js';\nimport type { PropertyInfo } from './model-info.js';\nimport { convertToTitleCase } from './util.js';\n\nexport type AutoFormFieldProps = Readonly<{\n  propertyInfo: PropertyInfo;\n  form: UseFormResult<any>;\n  options: FieldOptions;\n  disabled?: boolean;\n}>;\n\ntype CustomFormFieldProps = FieldDirectiveResult & Readonly<{ label?: string; disabled?: boolean }>;\n\nexport type FieldOptions = Readonly<{\n  /**\n   * The id to apply to the field.\n   */\n  id?: string;\n  /**\n   * The class names to add to the field.\n   */\n  className?: string;\n  /**\n   * The style to apply to the field.\n   */\n  style?: CSSProperties;\n  /**\n   * The label to show for the field. If not specified, a human-readable label\n   * is generated from the property name.\n   */\n  label?: string;\n  /**\n   * The placeholder to when the field is empty.\n   *\n   * Note that some field types, such as checkbox, do not support a placeholder.\n   */\n  placeholder?: string;\n  /**\n   * The helper text to display below the field.\n   *\n   * Note that some field types, such as checkbox, do not support a helper text.\n   */\n  helperText?: string;\n  /**\n   * The number of columns to span. This value is passed to the underlying\n   * FormLayout, unless a custom layout is used. In that case, the value is\n   * ignored.\n   */\n  colspan?: number;\n  /**\n   * Whether the field should be disabled.\n   */\n  disabled?: boolean;\n  /**\n   * Whether the field should be readonly.\n   */\n  readonly?: boolean;\n  /**\n   * The element to render for the field. This allows customizing field props\n   * that are not supported by the field options, or to render a different field\n   * component. Other field options are automatically applied to the element,\n   * and the element is automatically bound to the form. If not specified, a\n   * default field element is rendered based on the property type.\n   *\n   * The element must be a field component, such as TextField, TextArea,\n   * NumberField, etc., otherwise form binding will not work. For more\n   * sophisticated customizations, use the `renderer` option.\n   *\n   * If the field options also specify a renderer function, then the element is\n   * ignored.\n   *\n   * Example enabling the clear button for a text field:\n   * ```tsx\n   * {\n   *   element: <TextField clearButtonVisible />\n   * }\n   * ```\n   *\n   * Example rendering a text area instead of a text field:\n   * ```tsx\n   * {\n   *   element: <TextArea />\n   * }\n   * ```\n   */\n  element?: JSX.Element;\n  /**\n   * Allows to specify a custom renderer for the field, for example to render a\n   * custom type of field or apply an additional layout around the field. The\n   * renderer receives field props that must be applied to the custom field\n   * component in order to connect it to the form.\n   *\n   * In order to customize one of the default fields, or render a different type\n   * of field, consider using the `element` option instead.\n   *\n   * Example:\n   * ```tsx\n   * {\n   *   renderer: ({ field }) => (\n   *     <div>\n   *       <TextArea {...field} />\n   *       <p>Number of words: {calculateNumberOfWords()}</p>\n   *     </div>\n   *   )\n   * }\n   * ```\n   */\n  renderer?(props: { field: CustomFormFieldProps }): JSX.Element;\n  /**\n   * Validators to apply to the field. The validators are added to the form\n   * when the field is rendered.\n   * UseMemo is recommended for the validators, so that they are not recreated\n   * on every render.\n   */\n  validators?: Validator[];\n}>;\n\ntype CommonFieldProps = Pick<\n  FieldOptions,\n  'className' | 'colspan' | 'disabled' | 'helperText' | 'id' | 'label' | 'placeholder' | 'readonly' | 'style'\n>;\n\ntype FieldRendererProps = Readonly<{\n  model: AbstractModel;\n  field: FieldDirectiveResult;\n  element?: JSX.Element;\n  fieldProps: CommonFieldProps;\n}>;\n\nfunction getPropertyModel(form: UseFormResult<any>, propertyInfo: PropertyInfo) {\n  const pathParts = propertyInfo.name.split('.');\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return pathParts.reduce<any>((model, property) => (model ? model[property] : undefined), form.model);\n}\n\nfunction renderFieldElement(\n  defaultComponentType: ComponentType,\n  { element, field, fieldProps }: FieldRendererProps,\n  additionalProps: any = {},\n) {\n  const fieldElement = element ?? createElement(defaultComponentType);\n  return cloneElement(fieldElement, { ...fieldProps, ...additionalProps, ...fieldElement.props, ...field });\n}\n\nfunction AutoFormTextField(props: FieldRendererProps) {\n  return renderFieldElement(TextField, props);\n}\n\nfunction AutoFormIntegerField(props: FieldRendererProps) {\n  return renderFieldElement(IntegerField, props);\n}\n\nfunction AutoFormDecimalField(props: FieldRendererProps) {\n  return renderFieldElement(NumberField, props);\n}\n\nfunction AutoFormDateField(props: FieldRendererProps) {\n  const i18n = useDatePickerI18n();\n  return renderFieldElement(DatePicker, props, { i18n });\n}\n\nfunction AutoFormTimeField(props: FieldRendererProps) {\n  return renderFieldElement(TimePicker, props);\n}\n\nfunction AutoFormDateTimeField(props: FieldRendererProps) {\n  const i18n = useDateTimePickerI18n();\n  return renderFieldElement(DateTimePicker, props, { i18n });\n}\n\nfunction AutoFormEnumField(props: FieldRendererProps) {\n  const enumModel = props.model as EnumModel;\n  const items = Object.keys(enumModel[_enum]).map((value) => ({\n    label: convertToTitleCase(value),\n    value,\n  }));\n  return renderFieldElement(Select, props, { items });\n}\n\nfunction AutoFormBooleanField(props: FieldRendererProps) {\n  return renderFieldElement(Checkbox, props);\n}\n\nfunction AutoFormObjectField({ model, fieldProps }: FieldRendererProps) {\n  const part = useFormPart(model);\n  const jsonString = part.value ? JSON.stringify(part.value) : '';\n  return <TextArea {...fieldProps} value={jsonString} readonly />;\n}\n\nexport function AutoFormField(props: AutoFormFieldProps): JSX.Element | null {\n  const { form, propertyInfo, options } = props;\n  const label = options.label ?? propertyInfo.humanReadableName;\n  const model = getPropertyModel(form, propertyInfo);\n  const field = form.field(model);\n\n  const formPart = useFormPart(model);\n  const defaultValidators = useMemo(() => formPart.validators, []);\n  const { validators } = options;\n  useEffect(() => {\n    formPart.setValidators([...defaultValidators, ...(validators ?? [])]);\n  }, [validators]);\n\n  if (options.renderer) {\n    const customFieldProps = { ...field, disabled: props.disabled, label };\n    return options.renderer({ field: customFieldProps });\n  }\n\n  const fieldProps: CommonFieldProps = {\n    id: options.id,\n    className: options.className,\n    style: options.style,\n    label,\n    placeholder: options.placeholder,\n    helperText: options.helperText,\n    colspan: options.colspan,\n    disabled: options.disabled ?? props.disabled,\n    readonly: options.readonly,\n  };\n\n  const rendererProps: FieldRendererProps = { model, field, element: options.element, fieldProps };\n\n  switch (props.propertyInfo.type) {\n    case 'string':\n      return <AutoFormTextField {...rendererProps}></AutoFormTextField>;\n    case 'integer':\n      return <AutoFormIntegerField {...rendererProps}></AutoFormIntegerField>;\n    case 'decimal':\n      return <AutoFormDecimalField {...rendererProps}></AutoFormDecimalField>;\n    case 'date':\n      return <AutoFormDateField {...rendererProps}></AutoFormDateField>;\n    case 'time':\n      return <AutoFormTimeField {...rendererProps}></AutoFormTimeField>;\n    case 'datetime':\n      return <AutoFormDateTimeField {...rendererProps}></AutoFormDateTimeField>;\n    case 'enum':\n      return <AutoFormEnumField {...rendererProps}></AutoFormEnumField>;\n    case 'boolean':\n      return <AutoFormBooleanField {...rendererProps}></AutoFormBooleanField>;\n    case 'object':\n      return <AutoFormObjectField {...rendererProps}></AutoFormObjectField>;\n    default:\n      return null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
